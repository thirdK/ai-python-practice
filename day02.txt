변수명
stu_math_sum = 350 #스네이크 케이스
stuMathSum = 350 #카멜 케이스

#인덱싱 (슬라이싱)
s = "world"
print(s[2])
print(s[-1])  	#-1은 마지막 index를 가리킨다.

ss = "990212-2345243"
print(ss[7]) 	#하나만 추출할 때 indexing
addr = "서울시 강남구 역삼동 1번지"
print(addr[4:7]) 	#여러개를 추출할 때 slicing

연산자
/ 나누기는
// 두번쓰면 소수점 없이 몫만 챙긴다.


==========================================
Collection
	리스트 List , 튜플 Tuple, 딕셔너리 Dict, 셋 Set
	여러개의 값을 한번에 저장하는 자료형

리스트 List
지금까지 사용한 숫자 1, 문자 1 등 개별적, 독립적인 자료가 아닌
리스트는 이러한 자료들 여러개를 모아서 사용할 수 있게 해준다.
리스트에 넣는 자료들을 요소 element 라고 한다.

	1. 리스트는 []로 구성한다.
		list = [1,2,3,4,5]
		list = []

	2. 리스트는 다양한 자료형의 데이터를 한번에 담을 수 있다.
		(그러나 여러 자료형이 섞이는게 좋지는 않아서 
		하나의 리스트에 한 가지의 자료형을 담는걸 권장한다.)
		list = [1,2,3, "대한", "민국"]

	3. 리스트는 인덱싱(indexing)과 슬라이싱(slicing)이 가능하다.
		print(list[0])
		print(list[1:3]) #1번 index~2번 index(3번 미만)

	4. 리스트는 수정/삽입/삭제가 가능하다. (mutable 튜플은 immutable)
		list[0] = 100;

	5. 리스트는 연산이 가능하다.
		list_a = [1,2,3]
		list_b = [4,5,6]
		list_a + list_b -> [1,2,3,4,5,6]
		list_a * 3 ->[1,2,3,1,2,3,1,2,3]
		길이를 구하고 싶을 때 len()
		len(list_a) -> 3

리스트에 많이 사용되는 함수
	함수는 리스트명.함수명() 으로 사용한다.
	
	append(추가할요소) 
		리스트에 요소를 추가할 때 사용, 끝에만 추가

	insert(index, 추가할요소)
		리스트에 요소를 추가할 때 사용, 특정 위치를 지정하여 추가

	extend([추가할요소1,2,3...])
		리스트에 여러 요소를 추가할 때 사용
		list1.extend([1,2,3])#파괴적 처리
		list1 + list2 	#비파괴적 처리
		리스트 연결으로는 list1에 영향을 주지 않으나
		extend()를 사용하면 list1의 값에 직접적인 영향을준다
		(list1의 값이 바뀐다.)
	#기본적으로 자료를 사용할 때는 비파괴적으로 사용하는 것이 바람직하다.
	#가능하면 원본 데이터는 유지하면서 사용하는 것이 선택지가 더 넓다.

	del
		리스트에서 데이터 삭제
		사용방법이 다르다. 
		del list[삭제할인덱스]
		del list[시작인덱스:범위인덱스] 슬라이싱 사용가능
		del list[:] 인덱스 생략하면 전체삭제
		생략하면 처음 : 생략하면 끝

	
	pop()
		마지막 데이터를 삭제
		인덱스를 사용하면 끝에서 index번째 데이터 삭제
		pop(1) -> 마지막 인덱스를 0으로 생각하고 해당 인덱스 삭제


	remove(값)
		값과 일치하는 요소를 찾아 삭제
		단, 순차적으로 비교하여 처음 일치하는 값만 삭제한다(1개만 삭제)
		중복된 여러값을 제거하려면 반복문을 사용한다.
	
	clear()
		리스트 요소를 전부 한번에 삭제

	in / not in
		리스트에 존재하는 요소인지를 확인
		요소 in list
		요소 not int list
		bool값으로 반환한다.
		
IndexError : 없는 index에 접근하려고함 list에서 자주 등장하는 에러(예외)이다 

============================================

Dict 딕셔너리 (java 의 map, JS의 json 과 유사한 자료구조)
	리스트가 인덱스를 기반으로 값을 저장한다면 
	딕셔너리는 키값을 기반으로 값을 저장한다.

	1. {}를 사용하여 데이터들을 저장한다.
		dict = {"key": value,....}
		dict = {}

		dict = {	
			"name": "엔드게임",
			"type": "히어로 무비",
			"price": 10000
		}
	*조회는 index대신 key값으로 한다.
		dict["name"]  -> name 키값의 value를 리턴
	
	*List를 저장할 수도 있다.
		dict = {
			"감독":["안토니","루소"],
			"배우":["타노스","토르","헐크"]
		}
	List를 저장하면 해당 리스트의 index 사용 가능
		dict["배우"][1] -> 토르

	2. 수정/삽입/삭제가 가능하다. mutable
		수정은 dict["기존key"] = value
		삽입은 dict["새로운key"] = value
		삭제는 del dict["key"]

	3. 순서가 없으므로 인덱싱과 슬라이싱이 불가능하다.

KeyError : 딕에서 존재하지 않는 키값을 사용하면 발생하는 에러(예외)

========================================

Tuple 튜플 
	1. ()를 사용하여 작성한다.
		tuple = (3, 5, 9, 8 ,7)
		조회는 index로 -> tuple[0], tuple[1:]
	2. 리스트와 거의 대부분 유사하나, 튜플은 삽입, 수정 등이 불가능하다. immutable
		비파괴적 연산은 가능하다.
		tuple1 + tuple2
		tuple1 * 3
	3. 튜플은 1개의 원소로 작성할 때는 ,를 삽입한다. (1,)
		tuple = (5,)
		tuple = 5,  --> ,를 생략하면 type이 integer로 나올것이다.
	4. 튜플은 괄호를 생략할 수 있다.
		tuple = 3, 5


==========================================

Set 집합
	
	1. {}를 사용하여 작성한다. 
	(Dict도 {}를 사용하지만 key값의 유무로 구별된다.)
	
	2. 중복을 허용하지 않는다.
		이러한 특성을 활용하여 중복 제거 필터용으로 많이 사용된다.	

	3. 순서가 없다. unordered
	(리스트나 튜플은 순서가 있기때문에 ordered 인덱싱과 슬라이싱을 통해)
	(값을 꺼낼 수 있지만 딕셔너리와 셋은 순서가 없어 불가능하다.)

	4. set자료형에 저장된 값을 꺼내려면 리스트나 튜플로 변환하여 사용한다.
	(key값도 없으며 순서가 없기 때문에 index 접근이 불가하다)
		set = {1,2,3,..}
		li = list(set)

	5. 수정/삽입/삭제가 가능하다 mutable
		삽입 set.add(값)
		여러개 삽입 set.update([값1,값2,값3....])
		삭제 set.remove(value)
		index가 존재하지 않으므로 값으로 색인하여 삭제를 한다.

	교집합
	set1 = {1,2,3}
	set2 = {2,3,4}
	print(set1 & set2) -> 결과는 교집합인 {2, 3}
	print(set1.intersection(set2)) -> 결과는 교집합인 {2, 3}
	
	합집합
	print(set1 | set2)
	print(set1.union(set2))
	-> 결과는 합집합 {1, 2, 3, 4}

	차집합
	print(set1 - set2)
	print(set1.difference(set2))
	-> 결과는 차집합 {1}

===========================================
if
특정 조건을 만족하는지 여부에 따라 실행되는 코드가 달라져야할 때 사용된다.

	if 조건식:
		만족할 때 실행 코드
	else:
		만족하지 못할 때 실행 코드























