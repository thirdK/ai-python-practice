유명한 알고리즘

기본적인 처리 절차를 가지고 있는 좋은 알고리즘이다.
좋은 프로그램을 만들기 위한 사고방식이나 힌트가 많이 포함되어 있다.
유명한 알고리즘을 학습하는 것은 프로그래밍 기술 향상에 커다란 도움이 된다.

탐색 Search
Linear Search 선형 탐색 - 앞에서부터 순서대로 찾는다.
Binary Search 이진 탐색 - 범위를 절반씩 줄여서 찾는다. 단, 데이터가 정렬이 되어 있어야한다.
Hash Search 해시 탐색 - 검색 즉시 찾는다. 단, 저장할 때 가공해서 저장한다.

정렬 Sort
Selection Sort 단순 선택법 - 최소/최대값을 선택하여 앞/뒤부터 순서대로 나열
Bubble Sort 단순 교환법 - 옆에있는 데이터를 교환하면서 자리를 바꾼다.
Insertion Sort 단순 삽입법 - 데이터를 올바른 위치에 삽입하면서 자리를 바꾼다.
Quick Sort 퀵정렬 - 기준 데이터를 기반으로 대소 분할을 반복하여 자리를 바꾼다.

에라토스테네스의 체 Sieve of Eratosthenes - 소수 구하는 알고리즘
유클리드 알고리즘 - 최대 공약수를 구하는 알고리즘

======================================================

Linear Search 선형 탐색법

보관된 데이터를 맨 앞부터 순서대로 원하는 값을 찾을 때까지 탐색한다.
탐색 처리는 반복 구조를 사용하여 기술한다.
반복 구조에서는 종료 조건을 잊지 말자

첨자(index) 0  1  2  3  4
데이터	  4  2  3  5  1	찾을 데이터 : 5  -> 3번 인덱스



Binary Search 이진 탐색법

이진 탐색법은 탐색하는 범위를 절반씩 줄여서 참색하는 방법이다.
데이터들이 먼저 오름차순이나 내림차순으로 정렬되어 있어야만 쓸수 있다.

index	0    1    2    3   4    5    6
data	11, 13, 17, 19, 23, 29, 31  찾는 값은 17

1st		   3번 index(가운데 index)를 먼저 확인
2st		   19 <- 17이 아니므로 3번 index 이후는 탐색범위에서 제외
		   (이진 탐색법은 정렬이되있기 때문)
3st	      1번 index(남은 index중 가운데) 확인
4st	      13 <-17이 아니고 좌측index는 탐색범위에서 제외됨


이진 탐색법의 알고리즘
1. 가운데 요소를 선택
2. 선택된 요소의 데이터와 찾는 데이터를 비교
3. 탐색 범위를 절반으로 줄이는 처리
위의 알고리즘이 반복된다.
=============================================
Hash Search해시 탐색법

선형 탐색이나 이진 탐색의 전제 조건은 어떤 데이터가 어떤 요소(index)에 있는지
전혀 모르는 상태에서 검색을 시작한다는 것이다.
그러나 해시 탐색법은 데이터의 '내용'과  저장한 곳의 '요소'를 미리 저장할 때
연계를 해서 극히(***) 짧은 시간 안에 탐색할 수 있도록 고안된 알고리즘이다.

24인 데이터는 첨자 24에 넣고 36데이터는 첨자 36에 넣어두는 것
단지 2개의 데이터를 보관하는데 최소한 37개의 요소배열이 필요하다.
-> 낭비가 심해진다.

해시 탐색법의 특징은 나중에 데이터를 쉽게 찾도록 보관하는 단계에서 사전 준비를
해두는 것이 특징이다.

가장 알기 쉬운 방법은 데이터를 데이터의 숫자와 같은 방에 넣어두는 것이다.
하지만 메모리의 불필요한 누수가 커진다. 따라서 

먼저 방을 7개를 준비한다. index0 ~ index6

0 1 2 3 4 5 6

11 15 23 26
11%7(index의 수) = 4
15%7 = 1
23%7 = 2
26%7 = 5
나머지를 이용하여 나머지 값과 같은 index에 배분한다.

 방번호(해시값) = 데이터 % 7(방의갯수) <- 해시함수
=========================================

해시 탐색법으로 데이터 찾는 방법

찾을때도 저장할때 사용한 해시 함수를 다시 사용
데이터 값 % 7  -> 인덱스 번호

따라서 해시 탐색법을 사용하면 단 한번의 계산으로 찾고자 하는 공을 찾을 수 있다.
검색 시간을 놀라울 정도로 단축시킬 수 있다는 큰 장점이 있다.

해시 함수로 데이터를 보관하는 알고리즘
	- 해시 함수는 데이터의 저장소 첨자를 계산한다.
	- 저장소의 첨자가 겹치는 것을 '충돌'이라고 한다.
	- 충돌이 발생하면 옆의 빈 요소에 데이터를 보관한다.

1. 배열은 2개 준비한다.

-첫번째 배열은 데이터의 갯수만큼 준비한다. (임시배열) arrayD
0   1   2   3  4   5   6
12 25 36 20 30  8  42

-두번째 배열은 11개를 준비하여 0으로 초기화 한다. (실제 저장될 배열) arrayH

0 1 2 3 4 5 6 7 8 9 10 11
0 0 0 0 0 0 0 0 0 0  0  0

arrayD 첫번째 요소부터 순차적으로 해시값을 계산하여 arrayH로 저장한다.
지금은 요소수가 11개이므로 11로 나눈 나머지를 계산하여 저장한다.

해시값 = arrayD데이터 % 11(해시함수)

첫 번째 arrayD[0] = 12 를 해시함수에 넣어 계산하면 해시값은 1이 된다.

0  1   2  3  4  5  6  7  8  9  10  11
0 12  0  0  0  0  0  0  0  0   0    0

이미 다른 데이터가 할당 되어 있는지 확인하여 비어있으면 대입한다.
왜 확인이 필요하는냐는 다음에 자세히 나오지만 요소가 많으면 해시 값이
즉 나머지 값이 우연히 일치하는 경우가 많아 이미 데이터가 저장 되어 있을
가능성이 높다.

요소가 비어 있는지 확인 하려면 0이 있는지 확인하면 된다.

============================================

# 해시 탐색법에서는 이러한 해시값이 이미 존재하는 것을 '충돌' synonym 이라고 한다.

# 이러한 충돌이 발생하는 경우 즉 arrH[k] != 0 인 경우를 처리해야 한다.
# 해결책은 간단하다. 바로 옆의 요소가 비어 있으면 거기에 넣는다.
# arrH[k]옆의 요소는 arrH[k+1] 0인지의 여부를 확인한다.

***충돌에 대하여***
충돌이 너무 자주 일어나면 추가적인 처리가 많이 필요하게 된다.
해시 탐색법의 장점이 무색해진다.
충돌이 일어나지 않게 하려면 데이터가 많이 흩어지도록 해야한다.

저장할 공간이 커질수록 충돌의 가능성은 적어지지만 메모리의 사용량이 늘어나
알고리즘의 효율성이 떨어지게된다.

탐색 처리의 속도를 유지하는 것과 가능한 메모리를 적게 사용하는 요소(저장공간)의 수는
일반적으로 저장 데이터의 수의 1.5배에서 2배라고 알려져 있다.

=============================================
만약 저장공간에 데이터가 없어서 k+1로 다른자리를 찾는중 마지막 index까지 차있다면??

좀 더 간단한 방법을 사용해 보자. k를 하나 증가시키는 처리 k + 1 -> k 의
k+1을 arrH의 길이로 나누어 그 나머지를 k에 대입하는 방법이다. 즉
(k+1) % 11 -> k

k값이 0에서 10인 경우에는 11로 나눌 필요가 없지만 k값이 10을 초과하는 경우의 처리를 별도로
준비하는 것은 비효율적이다. 두 경우 모두 11로 나누는 처리를 거친 값을 대입한다.
k값이 0에서 10인 경우에는 이 과정을 거친 후에도 원래값과 같아서 문제가 없다.
k가 10을 넘어 11이 된다면 나머지가 0이 된다.
만약 arrH[0]에도 이미 데이터가 있다면 (k+1=12) 12%11 = 1이 되어 바로 옆칸을 확인하는 처리를
진행하게 된다. 언젠가는 빈칸을 발견한다.

=============================================

